/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package huffmanrevisited;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * A class that compresses text data using Huffman coding. 
 * 
 * @author Kevin Higgins
 */
public class HuffmanEncoder {
    private byte[] enc; // will hold the encoded data after a call to encode
    private HuffmanTree t;  // will hold the codings after a call to encode
    // creates a map of the frequencies of each character in the given
    // character sequence
    /*private public for testing */ public Map<Character, Integer> calcFreqs(CharSequence csq) {
	Map<Character, Integer> freqs = new HashMap<>(); // only ref to concrete class

	for (int i = 0; i < csq.length(); i++) {
	    Character c = csq.charAt(i);
	    if (freqs.containsKey(c)) {
		int amount = freqs.get(c) + 1;
		freqs.put(c, amount);
	    }
	    else {
		freqs.put(c, 1);
	    }
	}
	return freqs;
    }
/**
 * Encodes the given character sequence.
 * <p>
 * Calls methods in other classes to calculate
 * character frequencies, to transform these into a Huffman tree, and
 * to get a map of characters to codes; then uses this map to build a
 * binary string intermediate representation of the original text.
 * Finally this is converted to raw binary.
 * 
 * @param csq   the character sequence to be encoded
 * @return 
 */
    public void encode(CharSequence csq) {
	Map<Character, Integer> freqs = calcFreqs(csq);

	t = new HuffmanTree(freqs);
	/*
	System.out.println("Amount of chars (summed frequency at root): " + subtrees.get(0).freq);
	*/
	//printEncodings(getEncodingsFromTree(subtrees.get(0)));
	Map<Character, String> m = (t.getCodingsAsMap());
	byte[] enc = new byte[1048576]; // 1MB
	//System.out.println("Here comes");
	// encode all input data
	
	// I'm using a StringBuilder because there's no obvious limit
	// on how long the code for one char is and I have to append
	// these code sequences onto the remnants of the previous ones.
	StringBuilder holding = new StringBuilder("");
	int bytesWritten = 0;
	for (int i = 0; i < csq.length(); i++) {
	    // get this character's variable-length code from map m using the char as key
	    // append current character's code 
	    // after whatever unused bits (up to 7) are left
	    // over in holding
	    holding.append(m.get(csq.charAt(i))); 	    
	}
	enc = BinaryConversions.binCsqToByteArray(holding);
    }
    /**
     * Returns the tree created by a call to encode
     * 
     * @return a HuffmanTree containing the codings generated by a call to 
     * encode
     */
    public HuffmanTree getTree() {
	return t;
    }
    
    /**
     * Returns the compressed version of the text most recently passed to encode
     * 
     * @return a byte array of compressed text
     */
    public byte[] getEncoded() {
        return enc;
    }
    // this method should only be given a CharSequence (or String) of 8 1s or 0s. If 
    // given a longer one, it will only work from the first 8 chars.
    // Chars other than 1 will be treated as 0s.
    private byte binCsqToByte(CharSequence s) {
	byte b = 0;
	if (s.charAt(0) == '1') b+= 128;
	if (s.charAt(1) == '1') b+= 64;
	if (s.charAt(2) == '1') b+= 32;
	if (s.charAt(3) == '1') b+= 16;
	if (s.charAt(4) == '1') b+= 8;
	if (s.charAt(5) == '1') b+= 4;
	if (s.charAt(6) == '1') b+= 2;
	if (s.charAt(7) == '1') b+= 1;
	return b;
    }
}
